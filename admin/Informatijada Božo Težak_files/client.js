app.service('ClientService',function( ClientApi , api , Entity , $interval ){	console.log("service is online");	/*	api.call("SetWatcherDirectory",{directory:'watcher'}).ready(function(r){	});	*/	var t = {		_clientapi : ClientApi("http://localhost:8061"),		api : api("/api"),		_onFileStatusCallback:function( files ){ },		_onFileDataCallback:function( filedata ){ },		_filemap:{},		_directories:{},		_directoryObjectMap:{},		currentstate:null,		advancingstate:null,		id_subcontest_round:null,		subcontest:{},		subcontestround:{},		unreadMessageCount:0,		inAlert:false,		msg:null,		userstate:{},		state_index:0,		profile:{}, // User profile		sloagans:[],		rounds:[],		machine:{},		problems:{},		phases:[],		phase_index:null,		phase:null,		elapsed:0,		duration:0,		timer:null,		submitting:[],		notifications:{},		autoSubmitTimer:0,		autoSubmitInterval:15000,		updateContestInterval:5000,		getTestCase:function(problem,revision)		{			var tc = {				problem:problem,				revision:revision,				tests:[],				results:{} // per solution			}			t.api			.use('UserTestCase')			.call('getTests',{id_problem:problem.id})			.ready(function(tests){				angular.extendUpdate( tc.tests , tests );			});			t.getMaxTestsPerUser();			return tc;		},		maxTestsPerUser:0,		getMaxTestsPerUser:function(){			t.api				.use('UserTestCase')				.call('getMaxTestsPerUser')				.ready(function(r){					t.maxTestsPerUser = r;				});			return t.maxTestsPerUser;		},		addTest:function( testcase ){			var test = {				id:null,				id_problem:testcase.problem.id,				input:'',				expected:'',				actual:{}			};			t.api				.use('UserTestCase')				.call('addTest',{id_problem:testcase.problem.id})				.ready(function( newTest ){					if (newTest)					{						angular.extend( test , newTest );						testcase.tests.push( test );					}				});			// todo: call api		},		removeTest:function( testcase, test ){			var index = testcase.tests.indexOf(test);			if ( index >= 0) {				if (test.id != null)					t.api						.use('UserTestCase')						.call('removeTest',{id:test.id})						.ready(function(r){							testcase.tests.splice( index , 1 );						});			}		},		runTests:function(testcase){			var id_problem = testcase.problem.id;			var id_solution = testcase.revision.id;			var tests = testcase.tests;			testcase.busy=true;			t.api				.use('UserTestCase')				.callPost('runTests',{id_solution:id_solution,tests:tests})				.ready(function( results ){					for (var x in results)					{						if ( ! ( id_solution  in testcase.results ) )							testcase.results[ id_solution ] = {};						var res = results[x];						testcase.results[ id_solution ][ res.id_user_test ] = res;					}					console.log(testcase);					testcase.busy = false;				});		},		getProfile:function(){			t.api.use('User').call("getProfile").ready(function(r){				angular.extend( t.profile , r );				t.profile.$original = angular.copy( t.profile );			});			return t.profile;		},		resetProfileImage:function(){			t.profile.id_image = t.profile.$original.id_image;			t.profile.image = t.profile.$original.image;		},		setProfileImage:function( image ){			console.log( image );			t.api.use('Image').call('getImage',{id:image.id}).ready(function(r){				t.profile.id_image = r.id;				t.profile.image = r;			})		},		acceptTerms:function()		{			t.api.use('Subcontest').call('acceptTerms',{id_subcontest_round:t.id_subcontest_round}).ready(function( userstate ){				angular.extend(t.userstate , userstate);								t.init();			});		},		getFileDataForMapping:function( mappingObject ) {			for ( var directory in t._directoryObjectMap )				if (t._directoryObjectMap[directory] == mappingObject)					return t._directories[directory];			return null;		},		loadSloagans:function(){			t.api.use('Option').find({'option_group':'SLOAGAN'}).ready(function(r){				t.sloagans.length = 0;				for (var x in r)					t.sloagans.push( r[x] );			});		},		markAsRead:function(msg)		{			t.api.use('Notification').call('markAsReceived',{id:msg.id},function(r){					if ( r )					{						t.notifications[ note.id ].received = 1;						t.unreadMessageCount--;						t.msg = null;						// set next message						for ( var x in t.notifications ){							if (t.notifications[x].received == 0)								t.msg = t.notifications[x];						}					}			});		},		checkMessages:function(){			t.api.use('Notification').call('checkMessages').ready(function( notifications ){				for ( var x in notifications )				{					var note = notifications[x];					if ( (note.id in t.notifications) )						continue;					t.notifications[ note.id ] = note;					if ( parseInt( note.received ) == 0 )					{						if ( t.inAlert )							return;						if ( document.body.className == 'blurred' )						{							t.inAlert = true;							window.alert("Nova poruka");							t.inAlert = false;						}						t.unreadMessageCount++;						t.msg = note;					}				}			});		},		registerDirectory:function( directory , mappingObject ){			t._directories[ directory ] = {};			t._directoryObjectMap[ directory ] = mappingObject;		},		onFileStatus:function( callback ){			t._onFileStatusCallback = callback;			return t;		},		onFileData:function( callback ){			t._onFileDataCallback = callback;			return t;		},		sendSolutionToServer:function( problem , solution_file , language , readyCallback ) {			var problem = problem;			var sol_file = solution_file;			// add to queue			t.submitting.push( sol_file );			t._clientapi				.call("GetFileData",{					filename:solution_file.filename,					directory:problem.directory				})				.ready(function( file ){					var file = file;					var data = {						id_problem:problem.id,						id_language:language.id,						solution_file:file					};					t.api						.use('Subcontest')						.callPost('submitSolution',data)						.success(function( r ){							console.log("@submit",r);							var solution = r.result;							// remove from "queue"							var index = t.submitting.indexOf(  sol_file )							if (index >= 0)								t.submitting.splice( index , 1 );							// ready :-)							if (readyCallback)								readyCallback(problem, solution , file);						});			});		},		createIfNotExist:function( directory , filename , contents )		{			return t._clientapi				.call("CreateIfNotExist",					{						directory:directory,						filename:filename,						contents:contents					}				);		},		_getFileStatus:function(){				for (var directory in t._directories)				{					var d = directory;					t._clientapi						.call("GetFileStatus",							{								directory:directory							}						)						.ready(function(r,promise){							var directory  = promise.params.directory;							t._directories[ directory ] = r.FileData;							t._onFileStatusCallback(   r.FileData , t._directoryObjectMap[directory] );						});				}		},		getFileData:function( file ){			t._clientapi				.call("GetFileData",{filename: file.filename })				.ready(function( filedata ){					t._onFileDataCallback( filedata );				});		},		getRevisionWithContents:function( revision ){			return t.api				.use("Subcontest")				.call("getRevisionWithContents",{id:revision.id})			;		},		submit:function(){			t._getFileStatus();		},		onStateChangeCallback:function( currentstate , advancingstate ){},		onStateChange:function( callback ){			t.onStateChangeCallback = callback;			return t;		},		isAdvancing:false,		updateState:function( currentstate , advancingstate )		{			if (currentstate != t.currentstate)			{				t.currentstate = currentstate;				t.advancingstate = advancingstate;				t.onStateChangeCallback( t.currentstate , t.advancingstate );				var stateIndices = {					'LOGGED_IN' : 0,					'PROFILE_REVIEW' : 1,					'SLOAGAN_SELECTION' : 2,					'READY' : 3,					'SOLVING' : 4,					'BONUSE_CASE_OFFERED' : 5,					'SOLVING_COMPLETE' : 6,					'REVIEW' : 7,				}				t.state_index = stateIndices[ t.currentstate ];			}		},		advance:function( advancingState ){			if (t.isAdvancing)				return;			console.log("advancing...");			t.isAdvancing = true;			t.api				.use("Subcontest")				.call('advanceUserState',{					advancingstate:advancingState,					id_subcontest_round:t.id_subcontest_round				})				.ready(function(r){					t.isAdvancing = false;					if (!r)						return;					// update the state now!					t.updateState( r.currentstate , r.advancingstate );				});		},		setLanguage:function(){			for ( var x in t.rounds )			{				var id_subcontest_round = t.rounds[x].id;				var id_language = t.rounds[x].chosen_language.id				t.api				.use('Subcontest')				.call(					'setLanguage',{					id_subcontest_round:id_subcontest_round,					id_language:id_language				})				.ready(function(r){				});				break;			}		},		bindMachine:function(){			t._clientapi			.call('Identify')			.ready(function( machineData ){				data = machineData;				data.id_subcontest_round = t.id_subcontest_round;				t.api				.use('Subcontest')				.call('bindUserMachine',data)				.ready(function( machine ){					console.log( t.machine );					angular.extend( t.machine,machine );				});			});		},		updateSubcontestData:function(x,r){				angular.extend( t.subcontest , r[x].subcontest );				angular.extend( t.subcontestround , r[x] );				t.id_subcontest_round = r[x].id;				angular.extendUpdate( t.phases , r[x].phases );				t.phase_index = r[x].phase_index;				t.phase = r[x].phase;				t.elapsed = r[x].elapsed;				t.duration = r[x].duration;				// user state update				angular.extend( t.userstate , r[x].userstate );				t.updateState( r[x].userstate.state , r[x].advancingstate );				for (var y in r[x].problems) {					var id_problem = r[x].problems[y].id;					if( id_problem in t.problems )						t.problems[id_problem].is_problem_available = r[x].problems[y].is_problem_available;				}				angular.extend( t.rounds[x].phase , r[x].phase );		},		bonusCaseDismissed:false,		isBonusCaseOffering:false,		bonusCaseAnswered:false,		acceptBonusCase:function(){			t.bonusCaseAnswered = true;			t.api.use('Subcontest').call('acceptBonusCase',{id_subcontest_round:t.id_subcontest_round}).ready(function( userstate ){				angular.extend(t.userstate , userstate);			});		},		rejectBonusCase:function(){			t.bonusCaseAnswered = true;			t.api.use('Subcontest').call('rejectBonusCase',{id_subcontest_round:t.id_subcontest_round}).ready(function( userstate ){				angular.extend(t.userstate , userstate);				t.bonusCaseDismissed = true;			});		},		init:function(){			t.getProfile();			t.api				.use("Subcontest")				.call("getSubcontestsInProgress")				.ready(function( r ){					t.rounds = r;					for ( var x in r )					{						t.id_subcontest_round = r[x].id;						t.updateSubcontestData(x,r);						// Logo VS CPP defaults						if (r[x] && ( r[x].subcontest.languages.length == 1 ) )							r[x].chosen_language = r[x].subcontest.languages[0];						else							r[x].chosen_language = r[x].subcontest.languages[1];						var ext = r[x].chosen_language.default_extension;						// create startup files						for (var y in r[x].problems)						{							var problem = r[x].problems[y];							var basename = problem.raw_basename + ext;							var dirname = r[x].clientSolutionsDirectoryName; // "IBT\\" + r[x].id; // round id							// store into problem map							t.problems[problem.id] = problem;							t.registerDirectory( dirname , r[x].id );							r[x].problems[y].filename = basename;							r[x].problems[y].hash = "";							r[x].problems[y].directory = dirname;							var contents = "";							t.createIfNotExist( dirname , basename , contents ).ready(function(r){								// console.log(  dirname , basename , contents , r );							});						}						// work only on single round!						break;					}					t.bindMachine();			});			t.onFileStatus(function( filemap , round_id ){				t.autoSubmitTimer = t.autoSubmitInterval ;				var r = t.rounds;				for (var x in r)				{					if (  r[x].id != round_id)						continue;					for (var i in filemap)					{						for (var j in r[x].problems){							var problem = r[x].problems[j];							var file = filemap[i];							if ( problem.filename == file.filename )							{								var modified = false;								if ( problem.revisions.length == 0 )								{									modified  = true;									console.log("no revision data");								}								else								{									var current_revision = problem.revisions[0];									current_revision.local_modified = file.modified;									modified = (current_revision.hash != file.hash);									if (modified)									{										console.log("hashes differ",current_revision.hash,file.hash);										current_revision.state = "SENDING";									}								}								if ( modified )								{									t.sendSolutionToServer( problem , file  , r[x].chosen_language , function( problem , solution , file ){										var current_revision = problem.revisions[0];										if (current_revision)										{											if ( solution == null )											{												current_revision.state = "DELAYED";												return;											}											current_revision.state = solution.state;										}										if (  solution &&											(												problem.revisions.length == 0 ||												( problem.revisions.length > 0  && current_revision.revision < solution.revision )											)										){											solution.local_modified = file.modified;											problem.revisions.unshift( solution );										}									});								}							}						}					}				}			})		}	}	t.autoSubmitTimer = t.autoSubmitInterval;	$interval(function(){		t.api				.use("Subcontest")				.call("getSubcontestsInProgress")				.ready(function( r ){					for (var x in r)					{						t.updateSubcontestData(x,r);						// update solutions ( revisions)						for (var y in t.rounds[x].problems)						{							var problem = t.rounds[x].problems[y];							for (var z in problem.revisions) {								angular.extend(problem.revisions[z] , r[x].problems[y].revisions[z]);							}						}						// apply on single subcontest round!!						break;					}				});	},t.updateContestInterval);	$interval(function(){		t._getFileStatus();		t.checkMessages();	},t.autoSubmitInterval);	// update countdowns	$interval(function(){		t.autoSubmitTimer -= 1000;		// UPDATE BONUS CASE OFFER MODAL		if ( t.userstate && t.phase)		{			t.isBonusCaseOffering 			= ( t.phase.phaseName == 'BONUS_CASE_OFFER' ) 				&& (! (t.userstate.took_bonus_case*1) ) 				&& ( ! t.bonusCaseDismissed )			;		}		if ( t.countdown > 0 )			t.countdown--;		if ( t.elapsed > 0 )			t.elapsed++;		if ( t.phase && t.phase.countdown > 0 )			t.phase.countdown--;	// check if machine bound		if (t.machine == {} )			t.bindMachine();	},1000);	t.init();	t._getFileStatus();	t.loadSloagans();	return t;});
